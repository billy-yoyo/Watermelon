// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_src_compiler_object_Object
#include <src/compiler/object/Object.h>
#endif
#ifndef INCLUDED_src_compiler_object_builtin_coroutine_CoroutineObject
#include <src/compiler/object/builtin/coroutine/CoroutineObject.h>
#endif
#ifndef INCLUDED_src_compiler_signals_ExitSignal
#include <src/compiler/signals/ExitSignal.h>
#endif
#ifndef INCLUDED_src_compiler_signals_YieldSignal
#include <src/compiler/signals/YieldSignal.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_1e56c6a4d4601c82_30_new,"src.compiler.signals.YieldSignal","new",0x4811b57f,"src.compiler.signals.YieldSignal.new","src/compiler/signals/YieldSignal.hx",30,0x0700be72)
HX_LOCAL_STACK_FRAME(_hx_pos_1e56c6a4d4601c82_48_getName,"src.compiler.signals.YieldSignal","getName",0x220282a0,"src.compiler.signals.YieldSignal.getName","src/compiler/signals/YieldSignal.hx",48,0x0700be72)
HX_LOCAL_STACK_FRAME(_hx_pos_1e56c6a4d4601c82_53_toString,"src.compiler.signals.YieldSignal","toString",0xe242fb2d,"src.compiler.signals.YieldSignal.toString","src/compiler/signals/YieldSignal.hx",53,0x0700be72)
HX_LOCAL_STACK_FRAME(_hx_pos_1e56c6a4d4601c82_14_readYield,"src.compiler.signals.YieldSignal","readYield",0xb1e8ed76,"src.compiler.signals.YieldSignal.readYield","src/compiler/signals/YieldSignal.hx",14,0x0700be72)
HX_LOCAL_STACK_FRAME(_hx_pos_1e56c6a4d4601c82_19_writeYield,"src.compiler.signals.YieldSignal","writeYield",0x6d0721af,"src.compiler.signals.YieldSignal.writeYield","src/compiler/signals/YieldSignal.hx",19,0x0700be72)
namespace src{
namespace compiler{
namespace signals{

void YieldSignal_obj::__construct(bool isRead, ::src::compiler::object::builtin::coroutine::CoroutineObject coro,::Array< ::String > vars,::Array< ::Dynamic> values,::String wildcard, ::Dynamic timeLock){
            	HX_STACKFRAME(&_hx_pos_1e56c6a4d4601c82_30_new)
HXLINE(  31)		super::__construct(HX_("",00,00,00,00));
HXLINE(  32)		this->isRead = isRead;
HXLINE(  33)		this->coro = coro;
HXLINE(  34)		this->vars = vars;
HXLINE(  35)		this->values = values;
HXLINE(  36)		this->wildcard = wildcard;
HXLINE(  37)		if (hx::IsNull( timeLock )) {
HXLINE(  38)			this->isTimeLocked = false;
HXLINE(  39)			this->timeLock = (int)0;
            		}
            		else {
HXLINE(  41)			this->isTimeLocked = true;
HXLINE(  42)			this->timeLock = timeLock;
            		}
            	}

Dynamic YieldSignal_obj::__CreateEmpty() { return new YieldSignal_obj; }

void *YieldSignal_obj::_hx_vtable = 0;

Dynamic YieldSignal_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< YieldSignal_obj > _hx_result = new YieldSignal_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5]);
	return _hx_result;
}

bool YieldSignal_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0305b50d) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x0305b50d;
	} else {
		return inClassId==(int)0x1f7d2c12;
	}
}

::String YieldSignal_obj::getName(){
            	HX_STACKFRAME(&_hx_pos_1e56c6a4d4601c82_48_getName)
HXDLIN(  48)		return HX_("YieldSignal",75,0c,e2,2d);
            	}


::String YieldSignal_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_1e56c6a4d4601c82_53_toString)
HXDLIN(  53)		if (this->isRead) {
HXLINE(  54)			::String _hx_tmp = ((HX_("read yield, source: ",78,22,54,4a) + ::Std_obj::string(this->coro)) + HX_(", vars: ",c6,16,07,5b));
HXDLIN(  54)			::String _hx_tmp1 = ((_hx_tmp + ::Std_obj::string(this->vars)) + HX_(", wildcard: ",74,f6,d9,6a));
HXDLIN(  54)			::String _hx_tmp2 = ((((_hx_tmp1 + this->wildcard) + HX_(", timelock: ",92,f2,af,2b)) + this->timeLock) + HX_(" (is timelocked: ",2b,86,66,21));
HXDLIN(  54)			return ((_hx_tmp2 + ::Std_obj::string(this->isTimeLocked)) + HX_(")",29,00,00,00));
            		}
            		else {
HXLINE(  56)			::String _hx_tmp3 = ((HX_("write yield, target: ",f7,f1,7c,c1) + ::Std_obj::string(this->coro)) + HX_(", values: ",7c,2d,63,59));
HXDLIN(  56)			::String _hx_tmp4 = ((_hx_tmp3 + ::Std_obj::string(this->values)) + HX_(", wildcard: ",74,f6,d9,6a));
HXDLIN(  56)			::String _hx_tmp5 = ((((_hx_tmp4 + this->wildcard) + HX_(", timelock: ",92,f2,af,2b)) + this->timeLock) + HX_(" (is timelocked: ",2b,86,66,21));
HXDLIN(  56)			return ((_hx_tmp5 + ::Std_obj::string(this->isTimeLocked)) + HX_(")",29,00,00,00));
            		}
HXLINE(  53)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(YieldSignal_obj,toString,return )

 ::src::compiler::signals::YieldSignal YieldSignal_obj::readYield( ::src::compiler::object::builtin::coroutine::CoroutineObject readFrom,::Array< ::String > vars,::String wildcard, ::Dynamic timeLock){
            	HX_GC_STACKFRAME(&_hx_pos_1e56c6a4d4601c82_14_readYield)
HXDLIN(  14)		return  ::src::compiler::signals::YieldSignal_obj::__alloc( HX_CTX ,true,readFrom,vars,null(),wildcard,timeLock);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(YieldSignal_obj,readYield,return )

 ::src::compiler::signals::YieldSignal YieldSignal_obj::writeYield( ::src::compiler::object::builtin::coroutine::CoroutineObject writeTo,::Array< ::Dynamic> values,::String wildcard, ::Dynamic timeLock){
            	HX_GC_STACKFRAME(&_hx_pos_1e56c6a4d4601c82_19_writeYield)
HXDLIN(  19)		return  ::src::compiler::signals::YieldSignal_obj::__alloc( HX_CTX ,false,writeTo,null(),values,wildcard,timeLock);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(YieldSignal_obj,writeYield,return )


hx::ObjectPtr< YieldSignal_obj > YieldSignal_obj::__new(bool isRead, ::src::compiler::object::builtin::coroutine::CoroutineObject coro,::Array< ::String > vars,::Array< ::Dynamic> values,::String wildcard, ::Dynamic timeLock) {
	hx::ObjectPtr< YieldSignal_obj > __this = new YieldSignal_obj();
	__this->__construct(isRead,coro,vars,values,wildcard,timeLock);
	return __this;
}

hx::ObjectPtr< YieldSignal_obj > YieldSignal_obj::__alloc(hx::Ctx *_hx_ctx,bool isRead, ::src::compiler::object::builtin::coroutine::CoroutineObject coro,::Array< ::String > vars,::Array< ::Dynamic> values,::String wildcard, ::Dynamic timeLock) {
	YieldSignal_obj *__this = (YieldSignal_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(YieldSignal_obj), true, "src.compiler.signals.YieldSignal"));
	*(void **)__this = YieldSignal_obj::_hx_vtable;
	__this->__construct(isRead,coro,vars,values,wildcard,timeLock);
	return __this;
}

YieldSignal_obj::YieldSignal_obj()
{
}

void YieldSignal_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(YieldSignal);
	HX_MARK_MEMBER_NAME(coro,"coro");
	HX_MARK_MEMBER_NAME(vars,"vars");
	HX_MARK_MEMBER_NAME(values,"values");
	HX_MARK_MEMBER_NAME(wildcard,"wildcard");
	HX_MARK_MEMBER_NAME(isTimeLocked,"isTimeLocked");
	HX_MARK_MEMBER_NAME(timeLock,"timeLock");
	HX_MARK_MEMBER_NAME(isRead,"isRead");
	 ::src::compiler::signals::ExitSignal_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void YieldSignal_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(coro,"coro");
	HX_VISIT_MEMBER_NAME(vars,"vars");
	HX_VISIT_MEMBER_NAME(values,"values");
	HX_VISIT_MEMBER_NAME(wildcard,"wildcard");
	HX_VISIT_MEMBER_NAME(isTimeLocked,"isTimeLocked");
	HX_VISIT_MEMBER_NAME(timeLock,"timeLock");
	HX_VISIT_MEMBER_NAME(isRead,"isRead");
	 ::src::compiler::signals::ExitSignal_obj::__Visit(HX_VISIT_ARG);
}

hx::Val YieldSignal_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"coro") ) { return hx::Val( coro ); }
		if (HX_FIELD_EQ(inName,"vars") ) { return hx::Val( vars ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"values") ) { return hx::Val( values ); }
		if (HX_FIELD_EQ(inName,"isRead") ) { return hx::Val( isRead ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getName") ) { return hx::Val( getName_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"wildcard") ) { return hx::Val( wildcard ); }
		if (HX_FIELD_EQ(inName,"timeLock") ) { return hx::Val( timeLock ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"isTimeLocked") ) { return hx::Val( isTimeLocked ); }
	}
	return super::__Field(inName,inCallProp);
}

bool YieldSignal_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"readYield") ) { outValue = readYield_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"writeYield") ) { outValue = writeYield_dyn(); return true; }
	}
	return false;
}

hx::Val YieldSignal_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"coro") ) { coro=inValue.Cast<  ::src::compiler::object::builtin::coroutine::CoroutineObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vars") ) { vars=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"values") ) { values=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"isRead") ) { isRead=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"wildcard") ) { wildcard=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"timeLock") ) { timeLock=inValue.Cast< Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"isTimeLocked") ) { isTimeLocked=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void YieldSignal_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("coro","\x69","\xbd","\xc4","\x41"));
	outFields->push(HX_HCSTRING("vars","\xac","\x2b","\x49","\x4e"));
	outFields->push(HX_HCSTRING("values","\xe2","\x03","\xb7","\x4f"));
	outFields->push(HX_HCSTRING("wildcard","\xda","\xd9","\x17","\xa9"));
	outFields->push(HX_HCSTRING("isTimeLocked","\x81","\x75","\xaf","\xc9"));
	outFields->push(HX_HCSTRING("timeLock","\x98","\x1e","\x19","\xe8"));
	outFields->push(HX_HCSTRING("isRead","\x60","\x10","\x0e","\x69"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo YieldSignal_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::src::compiler::object::builtin::coroutine::CoroutineObject*/ ,(int)offsetof(YieldSignal_obj,coro),HX_HCSTRING("coro","\x69","\xbd","\xc4","\x41")},
	{hx::fsObject /*Array< ::String >*/ ,(int)offsetof(YieldSignal_obj,vars),HX_HCSTRING("vars","\xac","\x2b","\x49","\x4e")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(YieldSignal_obj,values),HX_HCSTRING("values","\xe2","\x03","\xb7","\x4f")},
	{hx::fsString,(int)offsetof(YieldSignal_obj,wildcard),HX_HCSTRING("wildcard","\xda","\xd9","\x17","\xa9")},
	{hx::fsBool,(int)offsetof(YieldSignal_obj,isTimeLocked),HX_HCSTRING("isTimeLocked","\x81","\x75","\xaf","\xc9")},
	{hx::fsFloat,(int)offsetof(YieldSignal_obj,timeLock),HX_HCSTRING("timeLock","\x98","\x1e","\x19","\xe8")},
	{hx::fsBool,(int)offsetof(YieldSignal_obj,isRead),HX_HCSTRING("isRead","\x60","\x10","\x0e","\x69")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *YieldSignal_obj_sStaticStorageInfo = 0;
#endif

static ::String YieldSignal_obj_sMemberFields[] = {
	HX_HCSTRING("coro","\x69","\xbd","\xc4","\x41"),
	HX_HCSTRING("vars","\xac","\x2b","\x49","\x4e"),
	HX_HCSTRING("values","\xe2","\x03","\xb7","\x4f"),
	HX_HCSTRING("wildcard","\xda","\xd9","\x17","\xa9"),
	HX_HCSTRING("isTimeLocked","\x81","\x75","\xaf","\xc9"),
	HX_HCSTRING("timeLock","\x98","\x1e","\x19","\xe8"),
	HX_HCSTRING("isRead","\x60","\x10","\x0e","\x69"),
	HX_HCSTRING("getName","\x01","\x22","\x82","\x1b"),
	HX_HCSTRING("toString","\xac","\xd0","\x6e","\x38"),
	::String(null()) };

static void YieldSignal_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(YieldSignal_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void YieldSignal_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(YieldSignal_obj::__mClass,"__mClass");
};

#endif

hx::Class YieldSignal_obj::__mClass;

static ::String YieldSignal_obj_sStaticFields[] = {
	HX_HCSTRING("readYield","\x17","\xe7","\x17","\xc2"),
	HX_HCSTRING("writeYield","\xee","\x94","\xf2","\x85"),
	::String(null())
};

void YieldSignal_obj::__register()
{
	hx::Object *dummy = new YieldSignal_obj;
	YieldSignal_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("src.compiler.signals.YieldSignal","\x0d","\x8a","\x93","\x9b");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &YieldSignal_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = YieldSignal_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(YieldSignal_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(YieldSignal_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< YieldSignal_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = YieldSignal_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = YieldSignal_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = YieldSignal_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace src
} // end namespace compiler
} // end namespace signals
