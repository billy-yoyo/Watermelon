// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
#include <hxcpp.h>

#ifndef INCLUDED_src_ast_Token
#include <src/ast/Token.h>
#endif
#ifndef INCLUDED_src_ast_base_BlockToken
#include <src/ast/base/BlockToken.h>
#endif
#ifndef INCLUDED_src_ast_base_BracketToken
#include <src/ast/base/BracketToken.h>
#endif
#ifndef INCLUDED_src_ast_base_CommaToken
#include <src/ast/base/CommaToken.h>
#endif
#ifndef INCLUDED_src_ast_base_EndLineToken
#include <src/ast/base/EndLineToken.h>
#endif
#ifndef INCLUDED_src_ast_base_KwdToken
#include <src/ast/base/KwdToken.h>
#endif
#ifndef INCLUDED_src_ast_base_VariableToken
#include <src/ast/base/VariableToken.h>
#endif
#ifndef INCLUDED_src_ast_script_AssignmentToken
#include <src/ast/script/AssignmentToken.h>
#endif
#ifndef INCLUDED_src_compiler_Core
#include <src/compiler/Core.h>
#endif
#ifndef INCLUDED_src_compiler_Scope
#include <src/compiler/Scope.h>
#endif
#ifndef INCLUDED_src_compiler_bytecode_Bytecode
#include <src/compiler/bytecode/Bytecode.h>
#endif
#ifndef INCLUDED_src_compiler_commands_CatchStatement
#include <src/compiler/commands/CatchStatement.h>
#endif
#ifndef INCLUDED_src_compiler_commands_Command
#include <src/compiler/commands/Command.h>
#endif
#ifndef INCLUDED_src_compiler_commands_StaticCatchStatement
#include <src/compiler/commands/StaticCatchStatement.h>
#endif
#ifndef INCLUDED_src_compiler_commands_TryCatchCommand
#include <src/compiler/commands/TryCatchCommand.h>
#endif
#ifndef INCLUDED_src_compiler_object_Object
#include <src/compiler/object/Object.h>
#endif
#ifndef INCLUDED_src_compiler_signals_CustomErrorSignal
#include <src/compiler/signals/CustomErrorSignal.h>
#endif
#ifndef INCLUDED_src_compiler_signals_ExitSignal
#include <src/compiler/signals/ExitSignal.h>
#endif
#ifndef INCLUDED_src_compiler_signals_SyntaxErrorSignal
#include <src/compiler/signals/SyntaxErrorSignal.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_dde3e7feb34008f0_25_new,"src.compiler.commands.TryCatchCommand","new",0x82b76efc,"src.compiler.commands.TryCatchCommand.new","src/compiler/commands/TryCatchCommand.hx",25,0x3a9aac55)
HX_LOCAL_STACK_FRAME(_hx_pos_dde3e7feb34008f0_102_copy,"src.compiler.commands.TryCatchCommand","copy",0xd68be599,"src.compiler.commands.TryCatchCommand.copy","src/compiler/commands/TryCatchCommand.hx",102,0x3a9aac55)
HX_LOCAL_STACK_FRAME(_hx_pos_dde3e7feb34008f0_109_setScope,"src.compiler.commands.TryCatchCommand","setScope",0x4079c676,"src.compiler.commands.TryCatchCommand.setScope","src/compiler/commands/TryCatchCommand.hx",109,0x3a9aac55)
HX_LOCAL_STACK_FRAME(_hx_pos_dde3e7feb34008f0_119_getName,"src.compiler.commands.TryCatchCommand","getName",0x2d8f3e9d,"src.compiler.commands.TryCatchCommand.getName","src/compiler/commands/TryCatchCommand.hx",119,0x3a9aac55)
HX_LOCAL_STACK_FRAME(_hx_pos_dde3e7feb34008f0_124_getFriendlyName,"src.compiler.commands.TryCatchCommand","getFriendlyName",0x0999aaa8,"src.compiler.commands.TryCatchCommand.getFriendlyName","src/compiler/commands/TryCatchCommand.hx",124,0x3a9aac55)
HX_LOCAL_STACK_FRAME(_hx_pos_dde3e7feb34008f0_128_run,"src.compiler.commands.TryCatchCommand","run",0x82ba85e7,"src.compiler.commands.TryCatchCommand.run","src/compiler/commands/TryCatchCommand.hx",128,0x3a9aac55)
HX_LOCAL_STACK_FRAME(_hx_pos_dde3e7feb34008f0_179_getBytecode,"src.compiler.commands.TryCatchCommand","getBytecode",0x24d95187,"src.compiler.commands.TryCatchCommand.getBytecode","src/compiler/commands/TryCatchCommand.hx",179,0x3a9aac55)
HX_LOCAL_STACK_FRAME(_hx_pos_dde3e7feb34008f0_190_reconstruct,"src.compiler.commands.TryCatchCommand","reconstruct",0x376800a0,"src.compiler.commands.TryCatchCommand.reconstruct","src/compiler/commands/TryCatchCommand.hx",190,0x3a9aac55)
HX_LOCAL_STACK_FRAME(_hx_pos_dde3e7feb34008f0_28_fromTokens,"src.compiler.commands.TryCatchCommand","fromTokens",0xb254c948,"src.compiler.commands.TryCatchCommand.fromTokens","src/compiler/commands/TryCatchCommand.hx",28,0x3a9aac55)
HX_LOCAL_STACK_FRAME(_hx_pos_dde3e7feb34008f0_75_fromBytecode,"src.compiler.commands.TryCatchCommand","fromBytecode",0xb4487da3,"src.compiler.commands.TryCatchCommand.fromBytecode","src/compiler/commands/TryCatchCommand.hx",75,0x3a9aac55)
namespace src{
namespace compiler{
namespace commands{

void TryCatchCommand_obj::__construct( ::src::compiler::Scope scope,::Array< ::Dynamic> code,::Array< ::Dynamic> catches,::Array< ::Dynamic> elseCode){
            	HX_STACKFRAME(&_hx_pos_dde3e7feb34008f0_25_new)
HXLINE(  92)		this->elseCodeProgress = (int)0;
HXLINE(  90)		this->codeProgress = (int)0;
HXLINE(  95)		super::__construct(scope);
HXLINE(  96)		this->code = code;
HXLINE(  97)		this->catches = catches;
HXLINE(  98)		this->elseCode = elseCode;
            	}

Dynamic TryCatchCommand_obj::__CreateEmpty() { return new TryCatchCommand_obj; }

void *TryCatchCommand_obj::_hx_vtable = 0;

Dynamic TryCatchCommand_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< TryCatchCommand_obj > _hx_result = new TryCatchCommand_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool TryCatchCommand_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x20538180) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x20538180;
	} else {
		return inClassId==(int)0x2c56d960;
	}
}

 ::src::compiler::commands::Command TryCatchCommand_obj::copy( ::src::compiler::Scope scope){
            	HX_GC_STACKFRAME(&_hx_pos_dde3e7feb34008f0_102_copy)
HXLINE( 103)		::Array< ::Dynamic> newCatches = ::Array_obj< ::Dynamic>::__new();
HXLINE( 104)		{
HXLINE( 104)			int _g = (int)0;
HXDLIN( 104)			::Array< ::Dynamic> _g1 = this->catches;
HXDLIN( 104)			while((_g < _g1->length)){
HXLINE( 104)				 ::src::compiler::commands::CatchStatement x = _g1->__get(_g).StaticCast<  ::src::compiler::commands::CatchStatement >();
HXDLIN( 104)				_g = (_g + (int)1);
HXDLIN( 104)				newCatches->push(x->copy(scope));
            			}
            		}
HXLINE( 105)		::Array< ::Dynamic> _hx_tmp = ::src::compiler::commands::Command_obj::copyArray(scope,this->code);
HXDLIN( 105)		::Array< ::Dynamic> _hx_tmp1;
HXDLIN( 105)		if (hx::IsNull( this->elseCode )) {
HXLINE( 105)			_hx_tmp1 = null();
            		}
            		else {
HXLINE( 105)			_hx_tmp1 = ::src::compiler::commands::Command_obj::copyArray(scope,this->elseCode);
            		}
HXDLIN( 105)		return  ::src::compiler::commands::TryCatchCommand_obj::__alloc( HX_CTX ,scope,_hx_tmp,newCatches,_hx_tmp1);
            	}


void TryCatchCommand_obj::setScope( ::src::compiler::Scope scope){
            	HX_STACKFRAME(&_hx_pos_dde3e7feb34008f0_109_setScope)
HXLINE( 110)		this->super::setScope(scope);
HXLINE( 111)		{
HXLINE( 111)			int _g = (int)0;
HXDLIN( 111)			::Array< ::Dynamic> _g1 = this->code;
HXDLIN( 111)			while((_g < _g1->length)){
HXLINE( 111)				 ::src::compiler::commands::Command cmd = _g1->__get(_g).StaticCast<  ::src::compiler::commands::Command >();
HXDLIN( 111)				_g = (_g + (int)1);
HXDLIN( 111)				cmd->setScope(scope);
            			}
            		}
HXLINE( 112)		if (hx::IsNotNull( this->elseCode )) {
HXLINE( 113)			int _g2 = (int)0;
HXDLIN( 113)			::Array< ::Dynamic> _g11 = this->elseCode;
HXDLIN( 113)			while((_g2 < _g11->length)){
HXLINE( 113)				 ::src::compiler::commands::Command cmd1 = _g11->__get(_g2).StaticCast<  ::src::compiler::commands::Command >();
HXDLIN( 113)				_g2 = (_g2 + (int)1);
HXDLIN( 113)				cmd1->setScope(scope);
            			}
            		}
            	}


::String TryCatchCommand_obj::getName(){
            	HX_STACKFRAME(&_hx_pos_dde3e7feb34008f0_119_getName)
HXDLIN( 119)		return HX_("TryCatchCommand",0b,14,72,d5);
            	}


::String TryCatchCommand_obj::getFriendlyName(){
            	HX_STACKFRAME(&_hx_pos_dde3e7feb34008f0_124_getFriendlyName)
HXDLIN( 124)		return HX_("try/catch",27,f9,66,c1);
            	}


 ::src::compiler::object::Object TryCatchCommand_obj::run(){
            	HX_GC_STACKFRAME(&_hx_pos_dde3e7feb34008f0_128_run)
HXLINE( 129)		 ::src::compiler::commands::Command command = null();
HXLINE( 130)		if (hx::IsNull( this->runningCatches )) {
HXLINE( 131)			try {
            				HX_STACK_CATCHABLE( ::src::compiler::signals::ExitSignal, 0);
HXLINE( 132)				while((this->codeProgress < this->code->length)){
HXLINE( 133)					command = this->code->__get(this->codeProgress).StaticCast<  ::src::compiler::commands::Command >();
HXLINE( 134)					bool _hx_tmp;
HXDLIN( 134)					if ((command->getName() != HX_("PipeReadCommand",e7,e2,01,95))) {
HXLINE( 134)						_hx_tmp = (command->getName() == HX_("PipeWriteCommand",9a,bf,b5,19));
            					}
            					else {
HXLINE( 134)						_hx_tmp = true;
            					}
HXDLIN( 134)					if (_hx_tmp) {
HXLINE( 135)						this->codeProgress++;
HXLINE( 136)						command->run();
            					}
            					else {
HXLINE( 138)						command->run();
HXLINE( 139)						this->codeProgress++;
            					}
            				}
            			}
            			catch( ::Dynamic _hx_e){
            				if (_hx_e.IsClass<  ::src::compiler::signals::ExitSignal >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::src::compiler::signals::ExitSignal e = _hx_e;
HXLINE( 143)					::String type = e->getName();
HXDLIN( 143)					 ::Dynamic source = e->msg;
HXLINE( 144)					if ((type == HX_("CustomErrorSignal",ff,6f,83,36))) {
HXLINE( 145)						source = hx::TCast<  ::src::compiler::signals::CustomErrorSignal >::cast(e)->source;
HXLINE( 146)						type = ( (::String)(source->__Field(HX_("getType",70,a2,8b,1f),hx::paccDynamic)()->__Field(HX_("getName",01,22,82,1b),hx::paccDynamic)()) );
            					}
HXLINE( 148)					this->runningCatches = ::Array_obj< ::Dynamic>::__new();
HXLINE( 149)					{
HXLINE( 149)						int _g = (int)0;
HXDLIN( 149)						::Array< ::Dynamic> _g1 = this->catches;
HXDLIN( 149)						while((_g < _g1->length)){
HXLINE( 149)							 ::src::compiler::commands::CatchStatement statement = _g1->__get(_g).StaticCast<  ::src::compiler::commands::CatchStatement >();
HXDLIN( 149)							_g = (_g + (int)1);
HXLINE( 150)							if (statement->checkType(type)) {
HXLINE( 151)								::Array< ::Dynamic> _hx_tmp1 = this->runningCatches;
HXDLIN( 151)								_hx_tmp1->push( ::src::compiler::commands::StaticCatchStatement_obj::__alloc( HX_CTX ,statement,this->scope,type,source));
            							}
            						}
            					}
HXLINE( 154)					if ((this->runningCatches->length == (int)0)) {
HXLINE( 154)						HX_STACK_DO_THROW(e);
            					}
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
            		}
HXLINE( 157)		bool _hx_tmp2;
HXDLIN( 157)		if (hx::IsNotNull( this->runningCatches )) {
HXLINE( 157)			_hx_tmp2 = (this->runningCatches->length == (int)0);
            		}
            		else {
HXLINE( 157)			_hx_tmp2 = true;
            		}
HXDLIN( 157)		if (_hx_tmp2) {
HXLINE( 158)			while((this->elseCodeProgress < this->elseCode->length)){
HXLINE( 159)				command = this->elseCode->__get(this->elseCodeProgress).StaticCast<  ::src::compiler::commands::Command >();
HXLINE( 160)				bool _hx_tmp3;
HXDLIN( 160)				if ((command->getName() != HX_("PipeReadCommand",e7,e2,01,95))) {
HXLINE( 160)					_hx_tmp3 = (command->getName() == HX_("PipeWriteCommand",9a,bf,b5,19));
            				}
            				else {
HXLINE( 160)					_hx_tmp3 = true;
            				}
HXDLIN( 160)				if (_hx_tmp3) {
HXLINE( 161)					this->elseCodeProgress++;
HXLINE( 162)					command->run();
            				}
            				else {
HXLINE( 164)					command->run();
HXLINE( 165)					this->elseCodeProgress++;
            				}
            			}
            		}
            		else {
HXLINE( 169)			while((this->runningCatches->length > (int)0)){
HXLINE( 170)				 ::src::compiler::commands::StaticCatchStatement statement1 = this->runningCatches->__get((int)0).StaticCast<  ::src::compiler::commands::StaticCatchStatement >();
HXLINE( 171)				statement1->statement->run(statement1->scope,statement1->type,statement1->source);
HXLINE( 172)				this->runningCatches->shift().StaticCast<  ::src::compiler::commands::StaticCatchStatement >();
            			}
            		}
HXLINE( 175)		return null();
            	}


 ::src::compiler::bytecode::Bytecode TryCatchCommand_obj::getBytecode(){
            	HX_STACKFRAME(&_hx_pos_dde3e7feb34008f0_179_getBytecode)
HXLINE( 180)		::cpp::VirtualArray arr = ::cpp::VirtualArray_obj::__new();
HXLINE( 181)		arr->push(this->code);
HXLINE( 182)		arr->push(this->elseCode);
HXLINE( 183)		{
HXLINE( 183)			int _g = (int)0;
HXDLIN( 183)			::Array< ::Dynamic> _g1 = this->catches;
HXDLIN( 183)			while((_g < _g1->length)){
HXLINE( 183)				 ::src::compiler::commands::CatchStatement statement = _g1->__get(_g).StaticCast<  ::src::compiler::commands::CatchStatement >();
HXDLIN( 183)				_g = (_g + (int)1);
HXLINE( 184)				arr->push(::cpp::VirtualArray_obj::__new(3)->init(0,statement->name)->init(1,statement->types)->init(2,statement->code));
            			}
            		}
HXLINE( 186)		return ::src::compiler::bytecode::Bytecode_obj::fromArray(arr,this->getCodeID());
            	}


::Array< ::Dynamic> TryCatchCommand_obj::reconstruct(){
            	HX_GC_STACKFRAME(&_hx_pos_dde3e7feb34008f0_190_reconstruct)
HXLINE( 191)		::Array< ::Dynamic> tokens = ::Array_obj< ::Dynamic>::__new();
HXLINE( 192)		tokens->push( ::src::ast::base::KwdToken_obj::__alloc( HX_CTX ,HX_("try",3b,69,58,00)));
HXLINE( 193)		 ::src::ast::base::EndLineToken _hx_tmp =  ::src::ast::base::EndLineToken_obj::__alloc( HX_CTX ,HX_(";",3b,00,00,00));
HXDLIN( 193)		tokens->push(::src::ast::base::BlockToken_obj::fromRaw(_hx_tmp->join(::src::compiler::commands::Command_obj::reconstructCommands(this->code),true)));
HXLINE( 194)		{
HXLINE( 194)			int _g = (int)0;
HXDLIN( 194)			::Array< ::Dynamic> _g1 = this->catches;
HXDLIN( 194)			while((_g < _g1->length)){
HXLINE( 194)				 ::src::compiler::commands::CatchStatement x = _g1->__get(_g).StaticCast<  ::src::compiler::commands::CatchStatement >();
HXDLIN( 194)				_g = (_g + (int)1);
HXLINE( 195)				tokens->push( ::src::ast::base::KwdToken_obj::__alloc( HX_CTX ,HX_("catch",3b,7c,21,41)));
HXLINE( 196)				::Array< ::Dynamic> types = ::Array_obj< ::Dynamic>::__new();
HXLINE( 197)				types->push( ::src::ast::base::VariableToken_obj::__alloc( HX_CTX ,x->name));
HXLINE( 198)				types->push( ::src::ast::script::AssignmentToken_obj::__alloc( HX_CTX ,HX_("=",3d,00,00,00)));
HXLINE( 199)				{
HXLINE( 199)					int _g2 = (int)0;
HXDLIN( 199)					::Array< ::String > _g3 = x->types;
HXDLIN( 199)					while((_g2 < _g3->length)){
HXLINE( 199)						::String type = _g3->__get(_g2);
HXDLIN( 199)						_g2 = (_g2 + (int)1);
HXLINE( 200)						types->push( ::src::ast::base::VariableToken_obj::__alloc( HX_CTX ,type));
HXLINE( 201)						types->push( ::src::ast::base::CommaToken_obj::__alloc( HX_CTX ,HX_(",",2c,00,00,00)));
            					}
            				}
HXLINE( 203)				types->pop().StaticCast<  ::src::ast::Token >();
HXLINE( 204)				tokens->push(::src::ast::base::BracketToken_obj::fromRaw(types));
HXLINE( 205)				 ::src::ast::base::EndLineToken _hx_tmp1 =  ::src::ast::base::EndLineToken_obj::__alloc( HX_CTX ,HX_(";",3b,00,00,00));
HXDLIN( 205)				tokens->push(::src::ast::base::BlockToken_obj::fromRaw(_hx_tmp1->join(::src::compiler::commands::Command_obj::reconstructCommands(x->code),true)));
            			}
            		}
HXLINE( 207)		if (hx::IsNotNull( this->elseCode )) {
HXLINE( 208)			 ::src::ast::base::EndLineToken _hx_tmp2 =  ::src::ast::base::EndLineToken_obj::__alloc( HX_CTX ,HX_(";",3b,00,00,00));
HXDLIN( 208)			tokens->push(::src::ast::base::BlockToken_obj::fromRaw(_hx_tmp2->join(::src::compiler::commands::Command_obj::reconstructCommands(this->elseCode),true)));
            		}
HXLINE( 210)		return tokens;
            	}


 ::src::compiler::commands::TryCatchCommand TryCatchCommand_obj::fromTokens( ::src::compiler::Scope scope,::Array< ::Dynamic> tokens){
            	HX_GC_STACKFRAME(&_hx_pos_dde3e7feb34008f0_28_fromTokens)
HXLINE(  30)		 ::src::ast::Token start = tokens->shift().StaticCast<  ::src::ast::Token >();
HXLINE(  31)		bool _hx_tmp;
HXDLIN(  31)		if ((start->getName() == HX_("KwdToken",c1,aa,4a,b9))) {
HXLINE(  31)			_hx_tmp = hx::IsNotEq( start->getContent(),HX_("try",3b,69,58,00) );
            		}
            		else {
HXLINE(  31)			_hx_tmp = true;
            		}
HXDLIN(  31)		if (_hx_tmp) {
HXLINE(  31)			HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Try/Catch must start with try keyword",e6,c3,04,ef)));
            		}
HXLINE(  32)		 ::src::ast::Token mainToken = tokens->shift().StaticCast<  ::src::ast::Token >();
HXLINE(  33)		if ((mainToken->getName() != HX_("BlockToken",8c,2a,40,e2))) {
HXLINE(  33)			HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Try code block must come straight after the try",a8,89,69,6f)));
            		}
HXLINE(  35)		::Array< ::Dynamic> catches = ::Array_obj< ::Dynamic>::__new();
HXLINE(  36)		 ::src::ast::Token kwd;
HXDLIN(  36)		 ::src::ast::Token typesToken;
HXDLIN(  36)		 ::src::ast::Token blockToken;
HXLINE(  37)		::Array< ::Dynamic> declTokens;
HXDLIN(  37)		::Array< ::Dynamic> declSpl;
HXDLIN(  37)		::Array< ::Dynamic> typesSpl;
HXLINE(  38)		 ::src::ast::Token nameToken;
HXDLIN(  38)		::Array< ::String > types;
HXDLIN(  38)		::Array< ::Dynamic> elseCode = null();
HXLINE(  39)		while((tokens->length > (int)0)){
HXLINE(  40)			kwd = tokens->shift().StaticCast<  ::src::ast::Token >();
HXLINE(  41)			bool _hx_tmp1;
HXDLIN(  41)			if ((kwd->getName() == HX_("KwdToken",c1,aa,4a,b9))) {
HXLINE(  41)				_hx_tmp1 = hx::IsEq( kwd->getContent(),HX_("else",b9,e4,14,43) );
            			}
            			else {
HXLINE(  41)				_hx_tmp1 = false;
            			}
HXDLIN(  41)			if (_hx_tmp1) {
HXLINE(  42)				blockToken = tokens->shift().StaticCast<  ::src::ast::Token >();
HXLINE(  43)				if ((blockToken->getName() != HX_("BlockToken",8c,2a,40,e2))) {
HXLINE(  43)					HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Else code must come after type declaration",e9,2d,26,21)));
            				}
HXLINE(  44)				elseCode = ::src::compiler::Core_obj::convert(scope,( (::Array< ::Dynamic>)(blockToken->getContent()) ));
HXLINE(  45)				goto _hx_goto_18;
            			}
HXLINE(  47)			bool _hx_tmp2;
HXDLIN(  47)			if ((kwd->getName() == HX_("KwdToken",c1,aa,4a,b9))) {
HXLINE(  47)				_hx_tmp2 = hx::IsNotEq( kwd->getContent(),HX_("catch",3b,7c,21,41) );
            			}
            			else {
HXLINE(  47)				_hx_tmp2 = true;
            			}
HXDLIN(  47)			if (_hx_tmp2) {
HXLINE(  47)				HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Catch statement must start with catch keyword",a9,ef,82,76)));
            			}
HXLINE(  48)			typesToken = tokens->shift().StaticCast<  ::src::ast::Token >();
HXDLIN(  48)			blockToken = tokens->shift().StaticCast<  ::src::ast::Token >();
HXLINE(  49)			if ((typesToken->getName() != HX_("BracketToken",d1,67,c5,1e))) {
HXLINE(  49)				HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Catch type declaration must come after keyword",99,9b,8a,90)));
            			}
HXLINE(  50)			if ((blockToken->getName() != HX_("BlockToken",8c,2a,40,e2))) {
HXLINE(  50)				HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Catch code must come after type declaration",ab,2e,98,7b)));
            			}
HXLINE(  52)			declTokens = ( (::Array< ::Dynamic>)(typesToken->getContent()) );
HXLINE(  53)			declSpl = ::src::compiler::commands::Command_obj::splitTokens(declTokens,HX_("AssignmentToken",4c,94,e1,56),null(),null());
HXLINE(  54)			if ((declSpl->length == (int)1)) {
HXLINE(  54)				HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Catch type declaration missing assignment token",a7,b2,d6,f0)));
            			}
HXLINE(  55)			if ((declSpl->length > (int)2)) {
HXLINE(  55)				HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Catch type declaration has too many assignment tokens",25,e1,21,7e)));
            			}
HXLINE(  56)			nameToken = declSpl->__get((int)0).StaticCast< ::Array< ::Dynamic> >()->__get((int)0).StaticCast<  ::src::ast::Token >();
HXLINE(  57)			if ((nameToken->getName() != HX_("VariableToken",fd,96,04,01))) {
HXLINE(  57)				HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Catch type declaration invalid name",5b,48,6d,d9)));
            			}
HXLINE(  59)			typesSpl = ::src::compiler::commands::Command_obj::splitTokens(declSpl->__get((int)1).StaticCast< ::Array< ::Dynamic> >(),HX_("CommaToken",04,01,3f,49),null(),null());
HXLINE(  60)			types = ::Array_obj< ::String >::__new();
HXLINE(  61)			{
HXLINE(  61)				int _g = (int)0;
HXDLIN(  61)				while((_g < typesSpl->length)){
HXLINE(  61)					::Array< ::Dynamic> type = typesSpl->__get(_g).StaticCast< ::Array< ::Dynamic> >();
HXDLIN(  61)					_g = (_g + (int)1);
HXLINE(  62)					bool _hx_tmp3;
HXDLIN(  62)					if ((type->length == (int)1)) {
HXLINE(  62)						_hx_tmp3 = (type->__get((int)0).StaticCast<  ::src::ast::Token >()->getName() != HX_("VariableToken",fd,96,04,01));
            					}
            					else {
HXLINE(  62)						_hx_tmp3 = true;
            					}
HXDLIN(  62)					if (_hx_tmp3) {
HXLINE(  62)						HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Catch type declaration invalid type",ca,c8,76,dd)));
            					}
HXLINE(  63)					types->push(type->__get((int)0).StaticCast<  ::src::ast::Token >()->getContent());
            				}
            			}
HXLINE(  66)			::Array< ::Dynamic> code = ::src::compiler::Core_obj::convert(scope,( (::Array< ::Dynamic>)(blockToken->getContent()) ));
HXLINE(  67)			catches->push( ::src::compiler::commands::CatchStatement_obj::__alloc( HX_CTX ,nameToken->getContent(),types,code));
            		}
            		_hx_goto_18:;
HXLINE(  69)		if ((tokens->length > (int)0)) {
HXLINE(  69)			HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Else must come at the end of the catch statement",a7,29,92,f0)));
            		}
HXLINE(  70)		if ((catches->length == (int)0)) {
HXLINE(  70)			HX_STACK_DO_THROW( ::src::compiler::signals::SyntaxErrorSignal_obj::__alloc( HX_CTX ,HX_("Try statement with no catch statement",cf,82,86,cf)));
            		}
HXLINE(  71)		return  ::src::compiler::commands::TryCatchCommand_obj::__alloc( HX_CTX ,scope,::src::compiler::Core_obj::convert(scope,( (::Array< ::Dynamic>)(mainToken->getContent()) )),catches,elseCode);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(TryCatchCommand_obj,fromTokens,return )

 ::src::compiler::commands::TryCatchCommand TryCatchCommand_obj::fromBytecode( ::src::compiler::Scope scope,::Array< ::Dynamic> arr){
            	HX_GC_STACKFRAME(&_hx_pos_dde3e7feb34008f0_75_fromBytecode)
HXLINE(  76)		::Array< ::Dynamic> catches = ::Array_obj< ::Dynamic>::__new();
HXLINE(  77)		::Array< ::Dynamic> code = ( (::Array< ::Dynamic>)(arr->shift().StaticCast<  ::src::compiler::bytecode::Bytecode >()->convert(scope)) );
HXLINE(  78)		::Array< ::Dynamic> elseCode = ( (::Array< ::Dynamic>)(arr->shift().StaticCast<  ::src::compiler::bytecode::Bytecode >()->convert(scope)) );
HXLINE(  79)		while((arr->length > (int)0)){
HXLINE(  80)			::cpp::VirtualArray arr1 = ( (::cpp::VirtualArray)(arr->shift().StaticCast<  ::src::compiler::bytecode::Bytecode >()->convert(scope)) );
HXLINE(  81)			catches->push( ::src::compiler::commands::CatchStatement_obj::__alloc( HX_CTX ,arr1->__get((int)0),arr1->__get((int)1),arr1->__get((int)2)));
            		}
HXLINE(  83)		return  ::src::compiler::commands::TryCatchCommand_obj::__alloc( HX_CTX ,scope,code,catches,elseCode);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(TryCatchCommand_obj,fromBytecode,return )


hx::ObjectPtr< TryCatchCommand_obj > TryCatchCommand_obj::__new( ::src::compiler::Scope scope,::Array< ::Dynamic> code,::Array< ::Dynamic> catches,::Array< ::Dynamic> elseCode) {
	hx::ObjectPtr< TryCatchCommand_obj > __this = new TryCatchCommand_obj();
	__this->__construct(scope,code,catches,elseCode);
	return __this;
}

hx::ObjectPtr< TryCatchCommand_obj > TryCatchCommand_obj::__alloc(hx::Ctx *_hx_ctx, ::src::compiler::Scope scope,::Array< ::Dynamic> code,::Array< ::Dynamic> catches,::Array< ::Dynamic> elseCode) {
	TryCatchCommand_obj *__this = (TryCatchCommand_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(TryCatchCommand_obj), true, "src.compiler.commands.TryCatchCommand"));
	*(void **)__this = TryCatchCommand_obj::_hx_vtable;
	__this->__construct(scope,code,catches,elseCode);
	return __this;
}

TryCatchCommand_obj::TryCatchCommand_obj()
{
}

void TryCatchCommand_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TryCatchCommand);
	HX_MARK_MEMBER_NAME(code,"code");
	HX_MARK_MEMBER_NAME(catches,"catches");
	HX_MARK_MEMBER_NAME(elseCode,"elseCode");
	HX_MARK_MEMBER_NAME(codeProgress,"codeProgress");
	HX_MARK_MEMBER_NAME(runningCatches,"runningCatches");
	HX_MARK_MEMBER_NAME(elseCodeProgress,"elseCodeProgress");
	 ::src::compiler::commands::Command_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TryCatchCommand_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(code,"code");
	HX_VISIT_MEMBER_NAME(catches,"catches");
	HX_VISIT_MEMBER_NAME(elseCode,"elseCode");
	HX_VISIT_MEMBER_NAME(codeProgress,"codeProgress");
	HX_VISIT_MEMBER_NAME(runningCatches,"runningCatches");
	HX_VISIT_MEMBER_NAME(elseCodeProgress,"elseCodeProgress");
	 ::src::compiler::commands::Command_obj::__Visit(HX_VISIT_ARG);
}

hx::Val TryCatchCommand_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"run") ) { return hx::Val( run_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"code") ) { return hx::Val( code ); }
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"catches") ) { return hx::Val( catches ); }
		if (HX_FIELD_EQ(inName,"getName") ) { return hx::Val( getName_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"elseCode") ) { return hx::Val( elseCode ); }
		if (HX_FIELD_EQ(inName,"setScope") ) { return hx::Val( setScope_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"getBytecode") ) { return hx::Val( getBytecode_dyn() ); }
		if (HX_FIELD_EQ(inName,"reconstruct") ) { return hx::Val( reconstruct_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"codeProgress") ) { return hx::Val( codeProgress ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"runningCatches") ) { return hx::Val( runningCatches ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"getFriendlyName") ) { return hx::Val( getFriendlyName_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"elseCodeProgress") ) { return hx::Val( elseCodeProgress ); }
	}
	return super::__Field(inName,inCallProp);
}

bool TryCatchCommand_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"fromTokens") ) { outValue = fromTokens_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fromBytecode") ) { outValue = fromBytecode_dyn(); return true; }
	}
	return false;
}

hx::Val TryCatchCommand_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"code") ) { code=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"catches") ) { catches=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"elseCode") ) { elseCode=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"codeProgress") ) { codeProgress=inValue.Cast< int >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"runningCatches") ) { runningCatches=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"elseCodeProgress") ) { elseCodeProgress=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TryCatchCommand_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("code","\x2d","\xb1","\xc4","\x41"));
	outFields->push(HX_HCSTRING("catches","\x69","\x99","\xa5","\xe9"));
	outFields->push(HX_HCSTRING("elseCode","\x86","\x12","\x16","\x6b"));
	outFields->push(HX_HCSTRING("codeProgress","\xfa","\xd9","\xa9","\x03"));
	outFields->push(HX_HCSTRING("runningCatches","\x2a","\xa1","\x84","\x6e"));
	outFields->push(HX_HCSTRING("elseCodeProgress","\x53","\xbc","\xb1","\x34"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo TryCatchCommand_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(TryCatchCommand_obj,code),HX_HCSTRING("code","\x2d","\xb1","\xc4","\x41")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(TryCatchCommand_obj,catches),HX_HCSTRING("catches","\x69","\x99","\xa5","\xe9")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(TryCatchCommand_obj,elseCode),HX_HCSTRING("elseCode","\x86","\x12","\x16","\x6b")},
	{hx::fsInt,(int)offsetof(TryCatchCommand_obj,codeProgress),HX_HCSTRING("codeProgress","\xfa","\xd9","\xa9","\x03")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(TryCatchCommand_obj,runningCatches),HX_HCSTRING("runningCatches","\x2a","\xa1","\x84","\x6e")},
	{hx::fsInt,(int)offsetof(TryCatchCommand_obj,elseCodeProgress),HX_HCSTRING("elseCodeProgress","\x53","\xbc","\xb1","\x34")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *TryCatchCommand_obj_sStaticStorageInfo = 0;
#endif

static ::String TryCatchCommand_obj_sMemberFields[] = {
	HX_HCSTRING("code","\x2d","\xb1","\xc4","\x41"),
	HX_HCSTRING("catches","\x69","\x99","\xa5","\xe9"),
	HX_HCSTRING("elseCode","\x86","\x12","\x16","\x6b"),
	HX_HCSTRING("codeProgress","\xfa","\xd9","\xa9","\x03"),
	HX_HCSTRING("runningCatches","\x2a","\xa1","\x84","\x6e"),
	HX_HCSTRING("elseCodeProgress","\x53","\xbc","\xb1","\x34"),
	HX_HCSTRING("copy","\xb5","\xbb","\xc4","\x41"),
	HX_HCSTRING("setScope","\x92","\xda","\x0d","\x87"),
	HX_HCSTRING("getName","\x01","\x22","\x82","\x1b"),
	HX_HCSTRING("getFriendlyName","\x0c","\x92","\xf4","\xaf"),
	HX_HCSTRING("run","\x4b","\xe7","\x56","\x00"),
	HX_HCSTRING("getBytecode","\xeb","\xb6","\x8b","\x7d"),
	HX_HCSTRING("reconstruct","\x04","\x66","\x1a","\x90"),
	::String(null()) };

static void TryCatchCommand_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(TryCatchCommand_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void TryCatchCommand_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(TryCatchCommand_obj::__mClass,"__mClass");
};

#endif

hx::Class TryCatchCommand_obj::__mClass;

static ::String TryCatchCommand_obj_sStaticFields[] = {
	HX_HCSTRING("fromTokens","\x64","\x1c","\x2b","\xd5"),
	HX_HCSTRING("fromBytecode","\xbf","\xcf","\xae","\xf7"),
	::String(null())
};

void TryCatchCommand_obj::__register()
{
	hx::Object *dummy = new TryCatchCommand_obj;
	TryCatchCommand_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("src.compiler.commands.TryCatchCommand","\x0a","\x81","\xa5","\x3a");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &TryCatchCommand_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = TryCatchCommand_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(TryCatchCommand_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(TryCatchCommand_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< TryCatchCommand_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = TryCatchCommand_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TryCatchCommand_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TryCatchCommand_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace src
} // end namespace compiler
} // end namespace commands
